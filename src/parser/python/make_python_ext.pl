# This script writes the extension .c file to stdout.  It reads a list of
# RTcmix function names from a file, and uses them in the .c file, so that
# Python will recognize them in RTcmix user scripts.     -JGG, 12-Feb-01

# location of rtcmix and name of extension passed in as args
$cmixdir = $ARGV[0];
$module = $ARGV[1];

$maxdispargs_h = "\"$cmixdir/H/maxdispargs.h\"";
$funclist = "./funclist";

# Open file containing RTcmix function names, one per line.  Save these so
# that we can use them below to build the individual dispatcher functions.

open FUNCLIST, "< $funclist" || die "Can't open $funclist ($!)";

while (<FUNCLIST>) {
   chop;
   push(@functions, $_);
}
close FUNCLIST;


# Print the .c file to stdout.
# NOTE NOTE NOTE: Make sure the prototype of parse_dispatch is correct!

print qq~
/* This file generated by the "make_python_ext.pl" script.  Don't edit here! */

#include "Python.h"
#include "rtcmix_python_ext.h"
#include <string.h>
#include $maxdispargs_h

extern double parse_dispatch(char *, double [], int);


static double
_call_parse_dispatch(PyObject *args, char *funcname)
{
   double   pp[MAXDISPARGS], retval = 0.0;

   if (PyTuple_Check(args)) {
      int i, count = PyTuple_Size(args);
      if (count > MAXDISPARGS) {
         fprintf(stderr, "Too many arguments to %s.\\n", funcname);
         exit(1);
      }
      for (i = 0; i < count; i++) {
         PyObject *obj = PyTuple_GET_ITEM(args, i);
         if (PyNumber_Check(obj)) {
            double val = 0.0;
            val = PyFloat_AsDouble(obj);
            pp[i] = val;
#ifdef DEBUG
            printf("%d: %8f\\n", i, val);
#endif
         }
         else if (PyString_Check(obj)) {
            /* dup the string, because we'll kill interpreter before
               insts have run. */
            char *str = strdup(PyString_AS_STRING(obj));
            pp[i] = (double) ((int) str);
#ifdef DEBUG
            printf("%d: \\"%s\\"\\n", i, str);
#endif
         }
         else {
            printf("%d: neither a number nor a string\\n", i);
            exit(1);
         }
      }
      retval = parse_dispatch(funcname, pp, count);
   }
   return retval;
}


~;


# Write individual dispatcher functions.
print "/* Dispatcher functions for RTcmix calls. Note: <self> not used. */\n";
foreach $func (@functions) {
print qq~
static PyObject *_$func(PyObject *self, PyObject *args)
{
   return PyFloat_FromDouble(_call_parse_dispatch(args, \"$func\"));
}
~;
}


# Print _rtcmix_funcs[], initialized with names of functions defined above.
print "\nstatic PyMethodDef _rtcmix_funcs[] = {\n";
foreach $func (@functions) {
   print "   {\"$func\", _$func, METH_VARARGS},\n";
}
print "   {NULL, NULL}          /* sentinel */\n";
print "};\n\n";


print qq~
int init_rtcmix_python_ext()
{
   PyObject *modobj;

   modobj = PyImport_AddModule("$module");
   if (modobj == NULL) {
      fprintf(stderr, "%s: PyImport_AddModule failure\\n", __FUNCTION__);
      return -1;
   }
   Py_InitModule("$module", _rtcmix_funcs);   /* aborts internally */
   return 0;
}

~;


